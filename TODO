🗂️ 1. Launcher – mecanism de repornire la crash
 Detectare crash

Adăugare handler pentru semnale (ex. SIGSEGV, SIGABRT) sau monitorizare proces copil.

Identificare cod de ieşire neprevăzut (non-zero)

 Comunicare între launcher şi aplicaţie

Definirea protocolului simplu (p. ex. pipe, socket local, fişier de semnalizare) prin care launcher-ul află starea “alive” a procesului principal.

Implementare ping/pong la intervale regulate (ex. “heartbeat”).

 Repornire automată

Dacă nu se primeşte răspuns (timeout) sau procesul principal se închide brusc, launcher-ul iniţiază o nouă instanţă.

Opţiuni de backoff (ex. retry după 1s, 2s, 5s etc.) pentru a nu intra într-un loop infinit.

 Roluri şi responsabilităţi

Launcher: monitorizează, reporneşte, îşi loghează propriile evenimente (ex. “Aplicaţia X a crăpat la ora Y”).

Aplicaţie principală: raportează periodic “Sunt OK” către launcher.

🗂️ 2. Sistem de logging şi colectare crash
 Alegerea framework-ului de logging

(ex. spdlog, log4cpp, boost::log) sau un mecanism propriu, dacă se preferă.

 Structura fişierelor de log

Definirea nivelurilor de severitate: DEBUG, INFO, WARN, ERROR, FATAL.

Configurarea rotaţiei log-urilor (daily/size-based).

 Interceptare excepţii / crash

În cazul unei excepţii neaşteptate: capturare catch-all (în C++, std::set_terminate, handler pentru std::exception).

Generare backtrace la momentul crash-ului (ex. folosind libunwind sau execinfo.h pe Linux).

Salvarea backtrace-ului într-un fişier separat sau în acelaşi log (timestamp + stack frames).

 Colectarea de informaţii adiţionale

Date de runtime (valorile variabilelor critice, configurări încărcate).

Context proces (PID, utilizator, memorie, CPU).

Eventuale snapshot-uri de configurare.

 Reproducere / raportare automată

Generare raport de crash (.txt, .json) cu toate informaţiile necesare.

Posibilă integrare cu un server extern (upload crash report) sau doar scriere locală.

🗂️ 3. TCP Handler (server/client)
 Specificaţii protocole / porturi

Definirea portului pe care ascultă serverul TCP.

Protocol de framing: delimitor simplu (de ex. newline), header-size-payload etc.

 Iniţializare socket

Creare socket (IPv4/IPv6), bind(), listen().

Setări opţionale: SO_REUSEADDR, TCP_KEEPALIVE, timeouts.

 Acceptare conexiuni

Managementul unui pool de thread-uri sau folosirea unui loop non-blocking (select/epoll).

Crearea/atribuirea de worker thread pentru fiecare client.

 Procesare request/response

Parsare mesaj de la client (ex. hand-shake iniţial, payload).

Business logic: ce se face cu datele primite.

Trimitere răspuns (confirmation, date solicitate etc.).

 Închidere şi cleanup

Închiderea corectă a socket-urilor la terminarea sesiunii.

Logging pentru conexiuni deschise/închise, erori de comunicare.

 Teste end-to-end

Script simplu client de test (trimite/primeşte).

Verificare scenarii de multiple conexiuni simultane, payload mare, date fragmentate.

📌 Plan de prioritizare
Launcher (monitor + restart)

Esenţial pentru stabilitate în producţie; recomandat să înceapă înaintea celorlalte module.

Logging & colectare crash

Pe măsură ce se dezvoltă modulul TCP, e util să existe logare detaliată care să ajute la depanare.

TCP Handler

După ce exista un mecanism stabil de repornire şi colectare crash, putem integra liniştit server-ul TCP.