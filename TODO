ğŸ—‚ï¸ 1. Launcher â€“ mecanism de repornire la crash
 Detectare crash

AdÄƒugare handler pentru semnale (ex. SIGSEGV, SIGABRT) sau monitorizare proces copil.

Identificare cod de ieÅŸire neprevÄƒzut (non-zero)

 Comunicare Ã®ntre launcher ÅŸi aplicaÅ£ie

Definirea protocolului simplu (p. ex. pipe, socket local, fiÅŸier de semnalizare) prin care launcher-ul aflÄƒ starea â€œaliveâ€ a procesului principal.

Implementare ping/pong la intervale regulate (ex. â€œheartbeatâ€).

 Repornire automatÄƒ

DacÄƒ nu se primeÅŸte rÄƒspuns (timeout) sau procesul principal se Ã®nchide brusc, launcher-ul iniÅ£iazÄƒ o nouÄƒ instanÅ£Äƒ.

OpÅ£iuni de backoff (ex. retry dupÄƒ 1s, 2s, 5s etc.) pentru a nu intra Ã®ntr-un loop infinit.

 Roluri ÅŸi responsabilitÄƒÅ£i

Launcher: monitorizeazÄƒ, reporneÅŸte, Ã®ÅŸi logheazÄƒ propriile evenimente (ex. â€œAplicaÅ£ia X a crÄƒpat la ora Yâ€).

AplicaÅ£ie principalÄƒ: raporteazÄƒ periodic â€œSunt OKâ€ cÄƒtre launcher.

ğŸ—‚ï¸ 2. Sistem de logging ÅŸi colectare crash
 Alegerea framework-ului de logging

(ex. spdlog, log4cpp, boost::log) sau un mecanism propriu, dacÄƒ se preferÄƒ.

 Structura fiÅŸierelor de log

Definirea nivelurilor de severitate: DEBUG, INFO, WARN, ERROR, FATAL.

Configurarea rotaÅ£iei log-urilor (daily/size-based).

 Interceptare excepÅ£ii / crash

Ãn cazul unei excepÅ£ii neaÅŸteptate: capturare catch-all (Ã®n C++, std::set_terminate, handler pentru std::exception).

Generare backtrace la momentul crash-ului (ex. folosind libunwind sau execinfo.h pe Linux).

Salvarea backtrace-ului Ã®ntr-un fiÅŸier separat sau Ã®n acelaÅŸi log (timestamp + stack frames).

 Colectarea de informaÅ£ii adiÅ£ionale

Date de runtime (valorile variabilelor critice, configurÄƒri Ã®ncÄƒrcate).

Context proces (PID, utilizator, memorie, CPU).

Eventuale snapshot-uri de configurare.

 Reproducere / raportare automatÄƒ

Generare raport de crash (.txt, .json) cu toate informaÅ£iile necesare.

PosibilÄƒ integrare cu un server extern (upload crash report) sau doar scriere localÄƒ.

ğŸ—‚ï¸ 3. TCP Handler (server/client)
 SpecificaÅ£ii protocole / porturi

Definirea portului pe care ascultÄƒ serverul TCP.

Protocol de framing: delimitor simplu (de ex. newline), header-size-payload etc.

 IniÅ£ializare socket

Creare socket (IPv4/IPv6), bind(), listen().

SetÄƒri opÅ£ionale: SO_REUSEADDR, TCP_KEEPALIVE, timeouts.

 Acceptare conexiuni

Managementul unui pool de thread-uri sau folosirea unui loop non-blocking (select/epoll).

Crearea/atribuirea de worker thread pentru fiecare client.

 Procesare request/response

Parsare mesaj de la client (ex. hand-shake iniÅ£ial, payload).

Business logic: ce se face cu datele primite.

Trimitere rÄƒspuns (confirmation, date solicitate etc.).

 Ãnchidere ÅŸi cleanup

Ãnchiderea corectÄƒ a socket-urilor la terminarea sesiunii.

Logging pentru conexiuni deschise/Ã®nchise, erori de comunicare.

 Teste end-to-end

Script simplu client de test (trimite/primeÅŸte).

Verificare scenarii de multiple conexiuni simultane, payload mare, date fragmentate.

ğŸ“Œ Plan de prioritizare
Launcher (monitor + restart)

EsenÅ£ial pentru stabilitate Ã®n producÅ£ie; recomandat sÄƒ Ã®nceapÄƒ Ã®naintea celorlalte module.

Logging & colectare crash

Pe mÄƒsurÄƒ ce se dezvoltÄƒ modulul TCP, e util sÄƒ existe logare detaliatÄƒ care sÄƒ ajute la depanare.

TCP Handler

DupÄƒ ce exista un mecanism stabil de repornire ÅŸi colectare crash, putem integra liniÅŸtit server-ul TCP.